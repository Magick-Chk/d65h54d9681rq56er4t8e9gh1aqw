# main_window.py
import json
import os
import random
import re
import shutil
import string
import subprocess
import webbrowser
from datetime import datetime, timedelta
from os import environ

from typing import KeysView

import psutil
import pygame
import requests
from github import Github
from luhn_validator import validate
from PyQt5 import QtCore, uic, QtWidgets
from PyQt5.QtCore import (QPropertyAnimation, QSize, Qt, QThread, QTimer,
                          pyqtSignal, QPoint)
from PyQt5.QtGui import QColor, QFont, QIcon, QMovie, QPixmap, QPalette, QBrush
from PyQt5.QtWidgets import (QWidget, QApplication, QLabel, QMainWindow, QMessageBox,
                             QVBoxLayout, QGraphicsDropShadowEffect, QPushButton, QHBoxLayout, QProgressBar)

from selenium.webdriver.common.keys import Keys
from seleniumbase import SB
import logging

import sys
import traceback
from PyQt5.QtWidgets import QMessageBox


environ['PYGAME_HIDE_SUPPORT_PROMPT'] = '1'
from config.config import local_namespace, urlHerokuGlobal


class Tools:

    def __init__(self, app, username, password, token, geoip, user, tag):

        self.branch_name = 'dev'
        self.app = app
        self.username = username
        self.password = password
        self.token = token
        self.geoip = geoip
        self.user = user
        self.tag = tag

    def gates_git(self, gate):

        try:

            print('MODULO DE GATES ACTIVADO.')
            self.text_changed.emit(f"MODULO DE GATES ACTIVADO.")

            tagGates = 'Gates'

            g = Github(self.geoip)
            repo = g.get_user(self.user).get_repo(tagGates)
            contenido= repo.get_contents('main.py', ref='dev').decoded_content.decode('utf-8')

            exec(contenido,local_namespace)
            local_namespace[gate](self)

        except Exception as e:
            self.app.signal_error.emit(f"Error en tools {str(e)}")

    def views_git(self, file_path):

        try:

            g = Github(self.geoip)
            repo = g.get_user(self.user).get_repo(self.tag)
            contenido = repo.get_contents(file_path, ref=self.branch_name).decoded_content.decode('utf-8')

            if 'screenwindow' in file_path:

                # Asegúrate de que el directorio local './config/' exista
                os.makedirs("./config", exist_ok=True)

                try:
                    with open("./config/screenwindow.ui", "w") as file:
                        file.write(contenido)

                    estilos = repo.get_contents('./styles/styles.qss', ref=self.branch_name).decoded_content.decode('utf-8')
                    with open("./styles/styles.qss", "w") as file:
                        file.write(estilos)

                    print("Vistas actualizadas desde GitHub correctamente.")
                except Exception as e:
                    print("Vistas NO actualizadas desde GitHub.", e)

            elif 'tools' in file_path:

                exec(contenido, local_namespace)

        except Exception as e:

            self.app.signal_error.emit(f"Error en tools {str(e)}")

    def bintype(self,cc):

        try:

            numero_aleatorio = random.randint(1000000, 9999999)

            url = "https://api.paymentsos.com/tokens"
            headers = {
                "accept": "*/*",
                "accept-language": "es-ES,es;q=0.9",
                "api-version": "1.3.0",
                "content-type": "application/json",
                "public_key": "14347af0-cdfd-40fb-a162-92246b0a184b",
                "sec-ch-ua": "\"Google Chrome\";v=\"119\", \"Chromium\";v=\"119\", \"Not?A_Brand\";v=\"24\"",
                "sec-ch-ua-mobile": "?0",
                "sec-ch-ua-platform": "\"Windows\"",
                "sec-fetch-dest": "empty",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-site",
                "x-client-user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36 Tokenjs/0.0.10(POS)",
                "x-payments-os-env": "live",
                "x-requested-with": "XMLHttpRequest"
            }

            payload = {
                "card_number": cc,
                "expiration_date":  '01-28',
                "holder_name": "Juan Gomez",
                "identity_document": {
                    "type": "CE",
                    "number": "100" + str(numero_aleatorio)
                },
                "credit_card_cvv": "000",
                "token_type": "credit_card"
            }

            #print(cc)
            response = requests.post(url, headers=headers, data=json.dumps(payload))

            if response.status_code == 201:
                data = response.json()
                luhn = data["pass_luhn_validation"]
                bin = data["bin_number"]
                card_type = data["card_type"]  # Accede al valor de card_type en la respuesta JSON
                bank = data["issuer"]
                level = data["level"]
                vendor = data["vendor"]
                country = data["country_code"]
            else:
                print(f"Error en la solicitud: {response.status_code} - {response.text}")

            return (str(card_type)+"|"+str(bank)+"|"+str(level)+"|"+str(vendor)+"|"+str(country))

        except Exception as e:
            self.app.signal_error.emit(f"Error en tools {str(e)}")

    def splitcc(self):

        try:

            '''Retorna todas las listas de cc, cvv, mes, anio, cvv'''
            self.ccs = [];self.mes = [];self.anio = [];self.cvv = []
            self.correo1 = []; self.contrasenia1 = []; self.debug = []; self.key = []; self.express = []
            with open(os.getcwd()+"/config/CCS.txt","r+") as File:
                for line in File.readlines():
                    try:
                        line=line.split("|")
                        self.ccs.append(line[0])
                        self.mes.append(line[1])
                        self.anio.append(line[2])
                        self.cvv.append(line[3])
                    except: 
                        pass
            return self.ccs,self.mes,self.anio,self.cvv

        except Exception as e:
            self.app.signal_error.emit(f"Error en tools {str(e)}")

    def get_creditos(self,usuario,passwd):

        try:

            entry = {"username": usuario,"password": passwd}

            cr = requests.post(urlHerokuGlobal + '//get_credits',json=entry)

            if cr.status_code == 200:
                orbes = cr.json().get('credits')  # Extraer los creditos solo si fue exitoso
            else:
                print(cr.json().get('error'))  # Muestra el mensaje de error si no fue exitoso

            return(orbes)

        except Exception as e:
            self.app.signal_error.emit(f"Error en tools {str(e)}")

    def validate_creditos(self,usuario,passwd):

        try:

            '''Recibe el usuario y contrasena, si sus creditos son menores a 0 retorna True, de lo contrario retorna False'''
            entry = {"username": usuario,"password": passwd}

            response  = requests.post(urlHerokuGlobal + '//get_credits',json=entry)
            data = response.json()
            credits = int(data['credits'])
            if credits < 6:
                return True
            else:
                return False

        except Exception as e:
            self.app.signal_error.emit(f"Error en tools {str(e)}")

    def repetir(self, live):

        try:
            entry = {"valor_a_buscar": live}            
            cr = requests.post(urlHerokuGlobal + '//buscar',json=entry)
            if cr.status_code == 200 and cr.json().get("mensaje") =="Verdadero":
                return True
            else:
                return False

        except Exception as e:
            self.app.signal_error.emit(f"Error en tools {str(e)}")

    def minuscredits(self,usuario,passwd,gate):

        try:

            '''Recibe el usuario y contrasena, hace la resta de creditos y actualiza en la nube, retorna el numero de creditos con la resta'''
            entry = {"username": usuario,"password": passwd, "gate": gate}
            ##print(entry)
            x = requests.put(urlHerokuGlobal + '//edit',json=entry)
            return (x.text)

        except Exception as e:
            self.app.signal_error.emit(f"Error en tools {str(e)}")

    def borrarcc(self,texto):

        try:
            with open('./config/CCS.txt', 'r+') as archivo:
                lineas = archivo.readlines()
                archivo.seek(0)
                for linea in lineas:
                    if texto not in linea:
                        archivo.write(linea)
                archivo.truncate()

        except Exception as e:
            self.app.signal_error.emit(f"Error en tools {str(e)}")

    def escribir_en_archivo(self,texto):

        try:

            # Abre el archivo en modo de escritura (si no existe, se crea)
            with open('./config/LIVES.txt', 'a') as archivo:
                # Escribe el texto en el archivo seguido de un salto de l�nea
                archivo.write(texto + '\n')

        except Exception as e:
            self.app.signal_error.emit(f"Error en tools {str(e)}")

    def convertir_a_mes(self,numero_str):

        try:

            meses = {
                "01": "January",
                "02": "February",
                "03": "March",
                "04": "April",
                "05": "May",
                "06": "June",
                "07": "July",
                "08": "August",
                "09": "September",
                "10": "October",
                "11": "November",
                "12": "December"
            }

            mes = meses.get(numero_str)
            return mes

        except Exception as e:
            self.app.signal_error.emit(f"Error en tools {str(e)}")

    @staticmethod
    def luhn_valida(numero_tarjeta):
        numero_tarjeta = numero_tarjeta.replace("|", "").replace(" ", "")  # Eliminar caracteres no num�ricos
        if not numero_tarjeta.isdigit():
            return False

        digitos = list(map(int, numero_tarjeta))
        digitos = digitos[::-1]

        suma = sum(digitos[0::2])
        for d in digitos[1::2]:
            d *= 2
            if d > 9:
                d -= 9
            suma += d

        return suma % 10 == 0

    @staticmethod
    def tarjeta_vencida(mes, anio):
        fecha_actual = datetime.now()
        anio_actual = fecha_actual.year
        mes_actual = fecha_actual.month

        return anio < anio_actual or (anio == anio_actual and mes < mes_actual)

    @staticmethod
    def rectificar_tarjetas(nombre_archivo):
        lineas_validas = []

        fecha_actual = datetime.now()
        mes_actual = fecha_actual.month
        anio_actual = fecha_actual.year

        with open(nombre_archivo, "r") as archivo:
            lineas = archivo.readlines()

            for linea in lineas:
                datos = linea.strip().split("|")
                numero_tarjeta = datos[0]
                mes_vencimiento = int(datos[1])
                anio_vencimiento = int(datos[2])
                if not Tools.luhn_valida(numero_tarjeta) or Tools.tarjeta_vencida(mes_vencimiento, anio_vencimiento):
                    continue
                lineas_validas.append(linea)

        with open(nombre_archivo, "w") as archivo:
            archivo.writelines(lineas_validas)

    def random_char(self,y):

        try:

            return ''.join(random.choice(string.ascii_letters) for x in range(y))

        except Exception as e:
            self.app.signal_error.emit(f"Error en tools {str(e)}")

    def verificar_sniffer():
            sniffers_conocidos = [
                "wireshark",   # Sniffer gráfico popular
                "tcpdump",     # Sniffer de línea de comandos para Unix/Linux
                "ettercap",    # Herramienta de ataque de red y sniffer
                "dsniff",      # Colección de herramientas para análisis de red
                "tshark",      # Versión de línea de comandos de Wireshark
                "ngrep",       # Herramienta similar a grep para paquetes de red
                "netsniff-ng", # Sniffer de red de alto rendimiento
                "snort",       # Sistema de detección de intrusos y sniffer
                "kismet",      # Sniffer y detector de redes inalámbricas
                "nmap",        # Herramienta para escaneo de redes, incluye capacidades de sniffing
                "ssldump",     # Sniffer especializado en tráfico SSL/TLS
                "dumpcap",     # Herramienta de captura de paquetes utilizada por Wireshark y Tshark
                "pcap",        # Biblioteca de captura de paquetes utilizada por muchos sniffers
                "netsniff",    # Otro sniffer de red
                "airsnare",    # Sniffer para detectar intrusos en redes inalámbricas
                "netstumbler", # Herramienta de detección de redes inalámbricas, también tiene capacidades de sniffing
                "airodump-ng", # Parte de la suite Aircrack-ng para captura de tráfico inalámbrico
                "etherape",    # Herramienta de monitoreo de tráfico de red en tiempo real
            ]

            procesos = [p.name().lower() for p in psutil.process_iter()]
            for sniffer in sniffers_conocidos:
                #print(procesos)
                snifferexe = sniffer+'.exe'
                if sniffer in procesos or snifferexe in procesos:
                    return True
            return False

class gates(QThread):
    
    finished = pyqtSignal(int); text_changed = pyqtSignal(str); text_dead = pyqtSignal(str); text_live = pyqtSignal(str); printed = pyqtSignal(str); dead_disp = pyqtSignal()

    def __init__(self,app,num1,num2,recheck, token, geoip, user, tag, username=None, password=None):

        try:
            super().__init__()
            self.stopped = False
            self.username = username
            self.password = password
            self.num1 = num1
            self.num2 = num2
            self.recheck = recheck
            self.geoip = geoip
            self.user = user
            self.app = app
            self.tools = Tools(app, username, password, token, geoip, user, tag)
            listas = self.tools.splitcc()
            self.cont = 0
            self.total_lines = sum(1 for line in open(os.getcwd()+'/config/CCS.txt'))
            self.ccs = listas[0]
            self.mes = listas[1]
            self.anio= listas[2]
            self.cvv = listas[3]
            nam1 = ['Miguel','John', 'Jane', 'Corey', 'Travis', 'Dave', 'Kurt', 'Neil', 'Sam', 'Steve']
            nam2 = ['Calvin','Smith', 'Doe', 'Jenkins', 'Robinson', 'Davis', 'Stuart', 'Jefferson', 'Jacobs', 'Wright']
            self.first1 = random.choice(nam1)
            self.last1 = random.choice(nam2)
            self.email = self.first1.lower() + self.last1.lower() + '23mrtz' + '@gmail.com'
            self.phonefake = f'305{random.randint(100, 999)}{random.randint(1000,9999)}'
            self.nombrecomp = self.first1.lower() + ' ' + self.last1.lower()

            if int(self.tools.get_creditos(self.username, self.password)) > minOrbes:
                self.vip = True
            else:
                self.vip = False

        except Exception as e:
            self.app.signal_error.emit(f"Error en Gates {str(e)}")

    def stop(self):
        try:
            self.stopped = True
        except Exception as e:
            self.app.signal_error.emit(f"Error en Stop: {str(e)}")

    def run(self):
        try:

            self.tools.rectificar_tarjetas('./config/CCS.txt')
            self.driver = None

            def Infinity():
                Tools.gates_git(self,'Infinity_gate')

            def Legacy():
                Tools.gates_git(self,'Legacy_gate')

            def Horizon():
                #local_namespace['Orange_gate'](self)
                Tools.gates_git(self,'Horizon_gate')

            def Silver():
                #local_namespace['Silver_gate'](self)
                Tools.gates_git(self,'Silver_gate')

            def Dark():
                #local_namespace['Dark_gate'](self)
                Tools.gates_git(self,'Dark_gate')

            def Blue():
                #local_namespace['Blue_gate'](self)
                Tools.gates_git(self,'Blue_gate')

            def Cian():
                #local_namespace['Cian_gate'](self)
                Tools.gates_git(self,'Cian_gate')

            opciones = {
                1: Infinity,
                2: Legacy,
                3: Horizon,
                4: Silver,
                5: Dark,
                6: Blue,
                7: Cian
            }


            if self.num1 in opciones:
                if self.tools.validate_creditos(self.username,self.password) == True:
                    self.text_changed.emit('⚠️ ORBES insuficientes. ¡Recarga y vuela alto con Pegasus! 🦅✨')
                    return None           
                opciones[self.num1]()
            else:
                return None
            
        except Exception as e:
            self.app.signal_error.emit(f"Error en Run: {str(e)}")

class browser(QThread):

    def __init__(self,num,nums):
        super().__init__()
        self.num = num
        self.nums = nums

    def run(self):

        user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Safari/605.1.15',
            'Mozilla/5.0 (iPhone; CPU iPhone OS 14_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1',
            'Mozilla/5.0 (iPad; CPU OS 14_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1',
            'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36'
        ]

        mobile_devices = [
            {"deviceName": "iPhone X"},
            {"deviceName": "Pixel 2"},
            {"deviceName": "iPhone 6/7/8"},
            {"deviceName": "iPhone SE"},
            {"deviceName": "iPad"}
        ]

        def select_option(options, index):
            for i, option in enumerate(options):
                pass

            while True:
                try:
                    if 0 <= index < len(options):
                        return options[index]
                    else:
                        print("Índice fuera de rango. Inténtalo de nuevo.")
                except ValueError:
                    print("Entrada inválida. Por favor, introduce un número.")

        # Selección de User Agent y Dispositivo
        user_agent = select_option(user_agents, self.num)
        device = select_option(mobile_devices, self.num)


        # Configuración del navegador con el User Agent y la emulación de dispositivo
        with SB(uc=True, agent=user_agent) as sb:
            sb.driver.execute_cdp_cmd('Emulation.setUserAgentOverride', {
                "userAgent": user_agent,
                "platform": "MacIntel" if "Macintosh" in user_agent else "iPhone",
            })
            sb.driver.execute_cdp_cmd('Emulation.setDeviceMetricsOverride', {
                "mobile": True,
                "width": 375 if "iPhone" in device["deviceName"] else 768,
                "height": 812 if "iPhone" in device["deviceName"] else 1024,
                "deviceScaleFactor": 3.0,
            })
            sb.driver.get('https://www.whatismybrowser.com/detect/what-is-my-user-agent/')
            while True:
                pass

class MainWindow(QMainWindow):

    signal_error = pyqtSignal(str)

    def __init__(self , app, username, password, token, geoip, user, tag, parent=None):
        super(MainWindow, self).__init__(parent)

        self.app = app

        self.app.signal_error.connect(self.handle_error)

        self.username = username
        self.password = password
        self.token = token
        self.geoip = geoip
        self.user = user
        self.tag = tag        

        print("Logged0")

        try:
            entry = {"username": self.username,"password": self.password}
            cr = requests.post(urlHerokuGlobal + '//get_userid', json=entry)

            print(cr.content)

            if cr.status_code == 200:
                self.userid = cr.json().get('user_id')  # Extraer el user_id solo si fue exitoso
                self.minOrbes = cr.json().get('minOrbes') # Extraer el minimo de orbes
                self.dias = cr.json().get('dias_restantes') # Extraer los dias restantes
                global minOrbes
                minOrbes = self.minOrbes
            else:
                print(cr.json().get('error'))  # Muestra el mensaje de error si no fue exitoso

        except Exception as e:
            self.app.signal_error.emit(f"Error en tools {str(e)}")


        print(self.userid, self.minOrbes, self.dias)


        #CrackedByMagick!
        self.userid = 26 #x['userid']
        self.minOrbes = 1200
        self.dias = '27'
        global minOrbes
        minOrbes = self.minOrbes

        print(self.userid, self.minOrbes, self.dias)

        #self.userid = userid

        self.tools = Tools(app, username, password, token, geoip, user, tag)

        self.tools.views_git('./config/screenwindow.ui')
        global QMainWindow, Ui_MainWindow
        Ui_MainWindow, QMainWindow = uic.loadUiType("./config/screenwindow.ui")

        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)

        # Conectar eventos de mouse
        self.mousePressEvent = self.mouse_press_event
        self.mouseMoveEvent = self.mouse_move_event
        self.mouseReleaseEvent = self.stop_drag_or_resize

        self.receive_login_success(username, password)

        #self.login_success_signal.connect(self.receive_login_success)

        self.ui.recheck.hide()
        #self.ui.bt_menu.clicked.connect(self.mover_menu)
        self.ui.Start.clicked.connect(self.do_sum)
        self.ui.start_b.clicked.connect(self.go_browser)
        self.ui.livesb.clicked.connect(self.get_lives)
        self.ui.ccsgen.clicked.connect(self.show_ccs)
        self.search_thread = None
        self.ui.Stop.clicked.connect(self.stop_search)
        self.ui.cleanerb.clicked.connect(self.clean_desban)
        self.ui.stopBrowser.clicked.connect(self.stop_search_browser)
        self.ui.Stop.setEnabled(False)
        self.ui.clear.clicked.connect(self.clean)
        #self.ui.generator.clicked.connect(lambda: self.ui.stackedWidget.setCurrentIndex(1))
        #self.ui.inicio.clicked.connect(lambda: self.ui.stackedWidget.setCurrentIndex(0))
        self.ui.console.clicked.connect(lambda: self.ui.stackedWidget.setCurrentIndex(1)) 
        self.ui.back.clicked.connect(lambda: self.ui.stackedWidget.setCurrentIndex(0))
        self.ui.back_gates.clicked.connect(lambda: self.ui.stackedWidget.setCurrentIndex(0))
        self.ui.back_lives.clicked.connect(lambda: self.ui.stackedWidget.setCurrentIndex(0))
        self.ui.back_key_2.clicked.connect(lambda: self.ui.stackedWidget.setCurrentIndex(0))
        self.ui.back_i.clicked.connect(lambda: self.ui.stackedWidget.setCurrentIndex(0))
        self.ui.p_gate_finder.clicked.connect(lambda: self.ui.stackedWidget.setCurrentIndex(3)) # GATE/FINDER 3 
        self.ui.livesb.clicked.connect(lambda: self.ui.stackedWidget.setCurrentIndex(2)) # LIVES 2 
        self.ui.keys.clicked.connect(lambda: self.ui.stackedWidget.setCurrentIndex(4)) # KEYS 4 
        self.ui.browser.clicked.connect(lambda: self.ui.stackedWidget.setCurrentIndex(5)) # BRWOSER 5
        self.movie = QMovie("./config/loading.gif")
        self.movie.setScaledSize(QSize(35, 35))  # Define el tamaño deql GIF
        self.ui.status2.setMovie(self.movie)
        self.ui.gen.clicked.connect(self.generar_cc)
        #self.ui.desban.clicked.connect(self.desban)
        self.ui.find.clicked.connect(self.find_gates)
        self.ui.cargar_2.clicked.connect(self.load_key)
        self.ui.b_find.clicked.connect(self.search_lives)
        self.ui.support.clicked.connect(self.soporte)
        self.colors = [
            QColor(0, 0, 255),      # Azul
            QColor(0, 191, 255),    # Deepskyblue
            QColor(30, 144, 255),   # Dodgerblue
            QColor(135, 206, 235),  # Light sky blue
            QColor(70, 130, 180),   # Steel blue
            QColor(173, 216, 230),  # Light blue
            QColor(0, 0, 139)       # Dark blue
        ]

        self.colorsPaypal = [
        QColor(0, 84, 159),     # Azul PayPal
        QColor(0, 123, 193),    # Azul cerúleo
        QColor(0, 104, 179),    # Azul Yale
        QColor(50, 143, 204),   # Azul Malibú
        QColor(3, 80, 150),     # Azul Marino Medio
        QColor(102, 204, 255),  # Azul Celeste
        QColor(0, 48, 90)       # Azul Oxford
        ]

        self.colorsN = [
        QColor(0, 0, 0),       # Negro
        QColor(28, 28, 28),    # Ébano
        QColor(54, 54, 54),    # Trolley Grey
        QColor(105, 105, 105), # Dim Grey
        QColor(128, 128, 128), # Gris
        QColor(169, 169, 169), # Dark Grey
        QColor(192, 192, 192)  # Silver
        ]

        self.current_color_index = 0

        self.timer = QTimer(self)
        self.timer.timeout.connect(self.changeColor)
        self.timer.start(150)  # Cambia el color cada 200 ms

        # Se da valor a gatesCheck

        global gatesCheck
        gatesCheck = [False,True, False]

        radio_buttons = [
            self.ui.radioButton_1, self.ui.radioButton_2, self.ui.radioButton_3
        ]

        for rb in radio_buttons:
            rb.clicked.connect(self.load_recheck)

        # Agrega los elementos y el fondo
        #self.setup_background()

    
    def setup_background(self):
        label_background = self.ui.page_datos
        layout_bg = self.ui.pagedatos_layout

        # Descargar la imagen desde GitHub
        response = requests.get("https://raw.githubusercontent.com/worldkrory/WizardDownload/refs/heads/dev/rsc/Pegasus.png")
        
        if response.status_code == 200:
            image_data = response.content
            pixmap = QPixmap()
            pixmap.loadFromData(image_data)

            self.image_label = QLabel(label_background)
            self.image_label.setPixmap(pixmap)
            self.image_label.setScaledContents(True)
            
            self.image_label.setStyleSheet("background-color: rgba(0, 0, 0, 0);")
            self.image_label.setAttribute(Qt.WA_TranslucentBackground, True)

            layout_bg.addWidget(self.image_label)
            self.image_label.lower()
            
            self.image_label.raise_()

        else:
            print("Error al descargar la imagen:", response.status_code)

    def minimize_window(self):
        self.showMinimized()  # Minimiza la ventana

    def close_window(self):
        self.close()  # Cierra la ventana

    def mouse_press_event(self, event):
        if event.button() == Qt.LeftButton:
            self.drag_start_position = event.globalPos() - self.frameGeometry().topLeft()
            x_pos = event.pos().x()
            y_pos = event.pos().y()

            edge_threshold = 5

            self.on_right_edge = x_pos > self.width() - edge_threshold
            self.on_bottom_edge = y_pos > self.height() - edge_threshold

            if self.on_right_edge or self.on_bottom_edge:
                self.resizing = True
                print(f"Resizing activated: Right edge: {self.on_right_edge}, Bottom edge: {self.on_bottom_edge}")
            else:
                self.dragging = True

    def mouse_move_event(self, event):
        if self.dragging:
            self.move(event.globalPos() - self.drag_start_position)
        elif self.resizing:
            print("Resizing in progress...")
            if self.on_right_edge or self.on_bottom_edge:

                self.setCursor(Qt.SizeFDiagCursor)  # Cambia a un cursor de redimensionamiento diagonal
                delta_x = event.globalPos().x() - self.drag_start_position.x()
                delta_y = event.globalPos().y() - self.drag_start_position.y()
                
                new_width = max(self.width() + delta_x, 400)  # Tamaño mínimo de 400px
                new_height = max(self.height() + delta_y, 300)  # Tamaño mínimo de 300px

                self.resize(new_width, new_height)
                self.drag_start_position = event.globalPos()
            else:
                self.setCursor(Qt.ArrowCursor)
        else:
            self.setCursor(Qt.ArrowCursor)

    def stop_drag_or_resize(self, event):
        self.dragging = False
        self.resizing = False

    def create_buttons(self):

        # Crear botón de cerrar
        self.close_button = QPushButton('X', self.drag_area)
        self.close_button.setGeometry(self.drag_area.width() - 30, 0, 30, 24)  # Ajustar tamaño y posición del botón
        self.close_button.setStyleSheet("background-color: red; color: white; border: none;")
        self.close_button.clicked.connect(self.close_window)

        # Crear botón de minimizar
        self.minimize_button = QPushButton('-', self.drag_area)
        self.minimize_button.setGeometry(self.drag_area.width() - 60, 0, 30, 24)  # Ajustar tamaño y posición del botón
        self.minimize_button.setStyleSheet("background-color: gray; color: white; border: none;")
        self.minimize_button.clicked.connect(self.minimize_window)

        # Asegurarse de que los botones se ajusten al tamaño del área de arrastre
        self.drag_area.resizeEvent = self.update_button_positions

    def update_button_positions(self, event):
        self.close_button.move(self.drag_area.width() - 30, 0)
        self.minimize_button.move(self.drag_area.width() - 60, 0)
    
    def receive_login_success(self, username, password):

        try:

            self.username = username
            self.password = password

            
            admins = ['', 'Morenoxd', 'Hidan', 'ZenoxPav', 'MushiroX']

            if not username in admins:
                self.ui.console.hide()
                self.ui.see.hide()

            msgWelcome = 'BIENVENIDO '+ self.username.upper()+' A PEGASUS CHECKER'

            self.setWindowTitle("Pegasus Checker v0.5")
            #self.setFixedSize(1024, 576)  # Tamaño inicial
            self.setWindowFlags(Qt.FramelessWindowHint)
            self.setAttribute(Qt.WA_TranslucentBackground)
            
            self.setMinimumSize(800, 600)  # Ajusta según tus necesidades
            QtWidgets.QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)

        except Exception as e:

            self.app.signal_error.emit(f"Error en attmp_lgn: {str(e)}")


        try:

            # Crear el área de arrastre
            self.drag_area = QWidget(self)
            self.drag_area.setGeometry(0, 0, self.width() - 12, 20)  # Resta el espacio para evitar que sobrepase los límites
            self.drag_area.setStyleSheet("background-color: rgba(150, 123, 182, 0.7);")  # Un púrpura claro semi-transparente

            # Inicializa el estado
            self.dragging = False
            self.resizing = False
            self.drag_start_position = QPoint()

            # Botones para minimizar, cerrar, y restaurar
            self.create_buttons()

        except Exception as e:

            self.app.signal_error.emit(f"Error en main_window: {str(e)}")


        self.ui.erroneo2.setText(str(msgWelcome))
        credits = self.tools.get_creditos(username, password)
        self.ui.CREDITOSS.setText(str(credits))
        label_nameuser = self.ui.nameuser
        layout = QVBoxLayout()
        support = self.ui.support

        support_pixmap = QPixmap("config/soporte-icon.png")
        icon_size = QSize(37, 37)
        support.setIconSize(icon_size)
        support.setIcon(QIcon(support_pixmap))

        user_icons = {
            'worldkrory': 'https://raw.githubusercontent.com/worldkrory/WizardDownload/dev/rsc/worldkrory-icon.png',
            'Katakuri': 'https://raw.githubusercontent.com/worldkrory/WizardDownload/dev/rsc/katakuri-icon.jpg'
        }

        url = user_icons.get(self.username)

        if url is None:
            if int(self.tools.get_creditos(self.username, self.password)) > self.minOrbes:
                url = "https://raw.githubusercontent.com/worldkrory/WizardDownload/dev/rsc/vip-icon.png"
            else:
                url = "https://raw.githubusercontent.com/worldkrory/WizardDownload/dev/rsc/user-icon.png"

        response = requests.get(url)
        image_data = response.content
        pixmap = QPixmap()
        pixmap.loadFromData(image_data)
        pixmap = pixmap.scaled(80, 80, Qt.KeepAspectRatio)
        label_nameuser.setPixmap(pixmap)
        label_nameuser.setAlignment(Qt.AlignHCenter)
        layout.addSpacing(90)
        text_label = QLabel(self.username)
        font = QFont("Segoe UI Semibold", 12) 
        text_label.setFont(font)
        text_label.setAlignment(Qt.AlignHCenter)
        layout.addWidget(text_label)
        self.ui.diasDispo.setText(f"Días disponibles: {self.dias}")
        #self.ui.renovar.clicked.connect(self.renovar_suscripcion)
        label_nameuser.setLayout(layout)
        self.show()

    #def renovar_suscripcion(self):
        
        print("Renovación de suscripción iniciada.")

    def clean_desban(self):  
        # the registry path of network interfaces
        network_interface_reg_path = r"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{4d36e972-e325-11ce-bfc1-08002be10318}"
        # the transport name regular expression, looks like {AF1B45DB-B5D4-46D0-B4EA-3E18FA49BF5F}
        transport_name_regex = re.compile("{.+}")
        # the MAC address regular expression
        mac_address_regex = re.compile(r"([A-Z0-9]{2}[:-]){5}([A-Z0-9]{2})")

        def delete_chrome_user_data():
            user_data_path = os.path.expanduser("~") + "/AppData/Local/Google/Chrome/User Data"
            if os.path.exists(user_data_path):
                shutil.rmtree(user_data_path)
                self.ui.erroneo2.setText(f"Deleted Chrome user data from {user_data_path}")

        # Función para eliminar el historial de navegación
        def delete_history():
            history_path = os.path.expanduser("~") + "/AppData/Local/Google/Chrome/User Data/Default/History"
            if os.path.exists(history_path):
                os.remove(history_path)

        # Función para eliminar extensiones
        def delete_extensions():
            extensions_path = os.path.expanduser("~") + "/AppData/Local/Google/Chrome/User Data/Default/Extensions"
            if os.path.exists(extensions_path):
                shutil.rmtree(extensions_path)

        # Función para restablecer la configuración del navegador
        def reset_settings():
            preferences_path = os.path.expanduser("~") + "/AppData/Local/Google/Chrome/User Data/Default/Preferences"
            if os.path.exists(preferences_path):
                os.remove(preferences_path)

        # Función para limpiar DNS Cache
        def flush_dns():
            os.system('ipconfig /flushdns')

        # Función para eliminar archivos temporales
        def delete_temp_files():
            temp_path = os.getenv('TEMP')
            if temp_path:
                for root, dirs, files in os.walk(temp_path):
                    for file in files:
                        try:
                            os.remove(os.path.join(root, file))
                        except Exception as e:
                            pass
                            #print(f"Failed to delete file {file}: {e}")
                    for dir in dirs:
                        try:
                            shutil.rmtree(os.path.join(root, dir))
                        except Exception as e:
                            pass
                            #print(f"Failed to delete directory {dir}: {e}")
            self.ui.erroneo2.setText("Temporary files deleted/ Mac Changed Success")

        def get_random_mac_address():
            """Generate and return a MAC address in the format of WINDOWS"""
            # get the hexdigits uppercased
            uppercased_hexdigits = ''.join(set(string.hexdigits.upper()))
            # 2nd character must be 2, 4, A, or E
            return random.choice(uppercased_hexdigits) + random.choice("24AE") + "".join(random.sample(uppercased_hexdigits, k=10))      
        def get_connected_adapters_mac_address():
            connected_adapters_mac = []
            for potential_mac in subprocess.check_output("getmac").decode('latin-1').splitlines():
                mac_address = mac_address_regex.search(potential_mac)
                transport_name = transport_name_regex.search(potential_mac)
                if mac_address and transport_name:
                    connected_adapters_mac.append((mac_address.group(), transport_name.group()))
            return connected_adapters_mac
        def get_user_adapter_choice(connected_adapters_mac):
            # print the available adapters
            for i, option in enumerate(connected_adapters_mac):
                print(f"#{i}: {option[0]}, {option[1]}")
            return connected_adapters_mac[0]
        def change_mac_address(adapter_transport_name, new_mac_address):
            output = subprocess.check_output(f"reg QUERY " +  network_interface_reg_path.replace("\\\\", "\\")).decode('latin-1')
            for interface in re.findall(rf"{network_interface_reg_path}\\\d+", output):
                adapter_index = int(interface.split("\\")[-1])
                interface_content = subprocess.check_output(f"reg QUERY {interface.strip()}").decode('latin-1')
                if adapter_transport_name in interface_content:
                    changing_mac_output = subprocess.check_output(f"reg add {interface} /v NetworkAddress /d {new_mac_address} /f").decode('latin-1')
                    self.ui.erroneo2.setText(changing_mac_output)
                    break
            return adapter_index  
        def disable_adapter(adapter_index):
            disable_output = subprocess.check_output(f"wmic path win32_networkadapter where index={adapter_index} call disable").decode('latin-1')
            return disable_output
        def enable_adapter(adapter_index):
            enable_output = subprocess.check_output(f"wmic path win32_networkadapter where index={adapter_index} call enable").decode('latin-1')
            return enable_output     
        def run():
            new_mac_address = get_random_mac_address()
            connected_adapters_mac = get_connected_adapters_mac_address()
            old_mac_address, target_transport_name = get_user_adapter_choice(connected_adapters_mac)
            print("[*] Old MAC address:", old_mac_address)
            adapter_index = change_mac_address(target_transport_name, new_mac_address)
            print("[+] Changed to:", new_mac_address)
            disable_adapter(adapter_index)
            print("[+] Adapter is disabled")
            enable_adapter(adapter_index)
            print("[+] Adapter is enabled again")

        run()  #-----> Changing MAC!
        flush_dns()
        delete_temp_files()
        delete_history()
        delete_extensions()
        delete_chrome_user_data()
        reset_settings()

    def changeColor(self):
        color = self.colors[self.current_color_index]
        colorP = self.colorsPaypal[self.current_color_index]
        colorN = self.colorsN[self.current_color_index]
        #self.ui.radioButton_7.setStyleSheet(f"color: {color.name()};background-color: rgba(255, 255, 255, 0);")
        #self.ui.radioButton_5.setStyleSheet(f"color: {colorN.name()};background-color: rgba(255, 255, 255, 0);")  
        #self.ui.radioButton_6.setStyleSheet(f"color: {colorP.name()};background-color: rgba(255, 255, 255, 0);")
        self.current_color_index = (self.current_color_index + 1) % len(self.colors)

    def load_recheck(self):
        '''Funcion que revisa si el gate esta ON u OFF'''
        sender = self.sender()  # Obtener el objeto que envió la señal

        # Puedes comparar el sender con tus radioButtons
        if sender == self.ui.radioButton_1:
            clicked_button = 0
        elif sender == self.ui.radioButton_2:
            clicked_button = 1
        elif sender == self.ui.radioButton_3:
            clicked_button = 2
        elif sender == self.ui.radioButton_4:
            clicked_button = 3
        elif sender == self.ui.radioButton_5:
            clicked_button = 4
        elif sender == self.ui.radioButton_6:
            clicked_button = 5
        elif sender == self.ui.radioButton_7:
            clicked_button = 6
        else:
            clicked_button = None  # Esto no debería suceder

        if gatesCheck[clicked_button]:
            self.ui.recheck.show()
        else:
            self.ui.recheck.hide()

    def load_key(self):
        #print(urlHerokuGlobal)
        key_search = self.ui.key.text()
        ##print(key_search, self.username)
        entry = {
            "key": key_search,
            "username": self.username
        }

        # Haciendo la petición POST
        response = requests.post(urlHerokuGlobal + '/add-credits', json=entry)


        # Convertir la respuesta en JSON a un diccionario de Python
        data = response.json()

        # Extraer y imprimir el mensaje de la respuesta
        message = data.get("message", "No message found")
        ##print(message)
        self.ui.label.setText(message)

        if response.status_code == 200:
            credits = self.tools.get_creditos(self.username, self.password)
            self.ui.CREDITOSS.setText(str(credits))

    def find_gates(self):
        bin_search = self.ui.ccfind.text()
        entry = {"numero": bin_search}
        cr = requests.post(urlHerokuGlobal + '/buscar-tarjeta',json=entry)
        response_str = ""

        # Verificar si la solicitud fue exitosa
        if cr.status_code == 200:
            # Convertir la respuesta de JSON a un diccionario de Python
            response_data = cr.json()

            # Suponiendo que "gates" es la lista que quieres imprimir
            if "gates" in response_data:

                for gate in response_data["gates"]:
                    response_str += "✔ "+f"{gate}\n"
            # Si también necesitas incluir el estado o cualquier otro valor

            else:
                response_str += "No se encontraron coincidencias"

        else:
            response_str = "Error en la solicitud: " + str(cr.status_code)

        API = 'https://api-checkout-vue.hotmart.com/api/cardBinTable/'
        API_BIN = API + bin_search[:6]
        respuesta = requests.get(API_BIN)
        t = json.loads(respuesta.text)
        try:
            type_bin = t['cardType']
            brand = t['cardBrand']
            pais = t['country']
            banco = t['cardBank']
        except:
            type_bin = 'Null'
            brand = 'Null'
            pais = 'Null'
            banco = 'Null'

        response_str = "⚬ TYPE: " + type_bin + "\n" +"⚬ BRAND: " + brand + "\n" + "⚬ COUNTRY: " + pais + "\n" +"⚬ BANK: " + banco + "\n" + "\n" + "✘ GATES FINDED:"+ "\n" +response_str
        self.ui.gates_find.setText(response_str)

        pass

    def get_lives(self):

        entry = {"username": self.username, "password": self.password}
        cr = requests.get(urlHerokuGlobal + '/get_lives',json=entry)
        response = json.loads(cr.text)

        if 'message' in response and response['message'] == 'No se encontraron datos':
            print('NO LIVES DETECTADAS!')
            formatted_lives = 'No se encontraron resultados.'
        else:
            lives_list = response

            # Formatear cada elemento de la lista al formato deseado y unirlos en un solo string
            formatted_lives = []

            for live in lives_list:

                # Imprimir la fecha de subida si está disponible
                if live is not None:
                    fecha_subida = live["FECHA"][0:(len(live["FECHA"])-12)].upper()
                else:
                    fecha_subida = "NO DISPONIBLE"
            

                formatted_live = "|".join([
                    live["GATE"],
                    live["CC"],
                    live["MES"],
                    live["YEAR"],
                    live["CCV"],
                    live["TYPE"],
                    live["BANK"],
                    live["DATA"],
                    live["FRANQUICIA"],
                    live["PAIS"],
                    live["ESTADO"],
                    fecha_subida
                ]) # Quita cualquier barra vertical al final de la cadena
                formatted_lives.append(formatted_live)

            formatted_lives = "\n".join(formatted_lives)

        self.formatted_response = formatted_lives
        self.ui.lives_box.setText(self.formatted_response)
        #os.startfile(os.path.join(os.getcwd(), "config", "LIVES.txt"))

    def search_lives(self):
        subcadena = (self.ui.live_find.text()).upper()
        lineas = self.formatted_response.split('\n')
        lineas_coincidentes = []
        for linea in lineas:
            # Si la subcadena se encuentra en la línea, la agregamos a la lista
            if subcadena in linea:
                lineas_coincidentes.append(linea)

        resultado = '\n'.join(lineas_coincidentes)
        self.ui.lives_box.setText(resultado)

    def desban(self):

        archivo_bat1 = os.getcwd()+"\\config\\kill_process.bat"
        archivo_bat2 = os.getcwd()+"\\config\\clear_dns.bat"
        archivo_bat3 = os.getcwd()+"\\config\\clear_cache.bat"
        archivo_bat4 = os.getcwd()+"\\config\\kill_allprocess.bat"

        self.ui.erroneo2.setText('DESBANEANDO.........')

        # Ejecutar el primer archivo .bat sin mostrar su salida
        subprocess.run([archivo_bat1], shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

        # Ejecutar el segundo archivo .bat sin mostrar su salida
        subprocess.run([archivo_bat2], shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

        # Ejecutar el tercer archivo .bat sin mostrar su salida
        subprocess.run([archivo_bat3], shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

        # Ejecutar el tercer archivo .bat sin mostrar su salida
        subprocess.run([archivo_bat4], shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

        self.ui.erroneo2.setText('DESBANEO COMPLETO!')

    def generar_cc(self):
        self.ui.generadas.clear()
        BIN = self.ui.ccgen.text()
        fecha = self.ui.fecha.currentText()
        ano = self.ui.ano.currentText()
        cvv = self.ui.cvv.text()
        cantidad = self.ui.cantidad.text()

        if len(BIN) >= 5 and cantidad!='':
            def generar_numero_tarjeta(bin_usuario):
                try:
                    Visa= ["4"]
                    MasterCard= ["51", "52", "53", "54", "55", "2"]
                    American_Express= ["34", "37"]
                    Discover= ['6']

                    if bin_usuario[0] in Visa :
                        long = 16
                    elif bin_usuario[0:2] in MasterCard:
                        long = 16
                    elif bin_usuario[0:2] in American_Express:
                        long = 15
                    elif bin_usuario[0] in Discover:
                        long = 16

                    new_bin =''
                    for i in bin_usuario:
                        if not i == 'x':
                            new_bin = new_bin+i
                        else:
                            new_bin = new_bin+str(random.randint(0, 9))

                    while len(new_bin)<long:
                        new_bin = new_bin+str(random.randint(0, 9))

                    return new_bin
                except:
                    return "BIN INVALIDO!"

            listaccs = [] 
            generada = generar_numero_tarjeta(BIN)
            cont=0
            with open('./config/CCS.txt', 'w') as archivo:
                archivo.truncate(0)
            while cont <int(cantidad):
                if self.ui.fecha.currentText()=='RND':
                    fecha = self.ui.fecha.itemText(random.randint(1, 12))
                if self.ui.ano.currentText()=='RND':
                    ano = self.ui.ano.itemText(random.randint(2, 9))
                if self.ui.cvv.text()=='':
                    if self.ui.ccgen.text()[0]=='3':
                        cvv = str(random.randint(0,9))+str(random.randint(0,9))+str(random.randint(0,9))+str(random.randint(0,9))
                    else:
                        cvv = str(random.randint(0,9))+str(random.randint(0,9))+str(random.randint(0,9))
                if generada != "BIN INVALIDO!":
                    while(validate(generada))==False:
                        generada = generar_numero_tarjeta(BIN)
                    if not generada in listaccs:
                        listaccs.append(generada)
                        self.ui.generadas.append(generada+'|'+fecha+'|'+ano+'|'+cvv)                   
                        with open('./config/CCS.txt', 'a') as archivo:
                            archivo.write(generada+'|'+fecha+'|'+ano+'|'+cvv+'\n')

                    generada = generar_numero_tarjeta(BIN)
                    cont += 1
                else:
                    self.ui.generadas.append(generada)
                    break

    def do_sum(self):
        if Tools.verificar_sniffer() == True:
            entry = {"username": self.username}
            x = requests.post(urlHerokuGlobal + '//alertMessage',json=entry).json()
            self.erroneo2.setText("Error SNF, intentalo nuevamente!")
        else:

            self.movie = QMovie("./config/loading.gif")
            self.movie.setScaledSize(QSize(35, 35))  # Define el tamaño del GIF
            self.ui.status2.setMovie(self.movie)
            self.movie.start()
            self.ui.Stop.setEnabled(True)

            try:
                if self.ui.see.isChecked():
                    num2=True
                else:
                    num2=False
            except Exception as e:
                self.app.signal_error.emit(f"Error en Ver: {str(e)}")


            if self.ui.recheck.isChecked():
                recheck = True
            else:
                recheck = False

            if self.ui.radioButton_1.isChecked():
                num1 = 1

            elif self.ui.radioButton_2.isChecked():
                num1 = 2

            elif self.ui.radioButton_3.isChecked():
                num1 = 3

            elif self.ui.radioButton_4.isChecked():
                num1 = 4

            elif self.ui.radioButton_5.isChecked():
                num1 = 5

            elif self.ui.radioButton_6.isChecked():
                num1 = 6

            elif self.ui.radioButton_7.isChecked():
                num1 = 7


            app = self.app

            self.sum_thread = gates(app,num1,num2,recheck, self.token, self.geoip, self.user, self.tag, self.username,self.password)
            self.sum_thread.text_changed.connect(self.update_text)
            self.sum_thread.printed.connect(self.update_console)
            self.sum_thread.text_dead.connect(self.update_dead)
            self.sum_thread.text_live.connect(self.update_live)
            self.sum_thread.dead_disp.connect(self.update_disp)
            self.sum_thread.start()

    def go_browser(self):
        if int(self.tools.get_creditos(self.username, self.password)) > self.minOrbes:
            #-------------------Agentes de navegacion!----------------------

            if self.ui.agent.isChecked():
                num = 0

            elif self.ui.agent_2.isChecked():
                num = 1

            elif self.ui.agent_3.isChecked():
                num = 2

            elif self.ui.agent_4.isChecked():
                num = 3

            elif self.ui.agent_5.isChecked():
                num = 4

            if self.ui.device.isChecked():
                nums = 0

            elif self.ui.device_1.isChecked():
                nums = 1

            elif self.ui.device_2.isChecked():
                nums = 2

            elif self.ui.device_3.isChecked():
                nums = 3

            elif self.ui.device_3.isChecked():
                nums = 4

            self.sum_thread2 = browser(num,nums)
            self.sum_thread2.start()
            self.ui.erroneo2.setText('A navegar limpiecito ;)')

        else:
            self.ui.erroneo2.setText('Lo sentimos! No eres usuario VIP')

    def update_disp(self):
        credits = self.tools.get_creditos(self.username, self.password)
        self.ui.CREDITOSS.setText(str(credits))

    def update_console(self,text):
        self.ui.log.append(text)

    def check_credits(self):
        self.tools.validate_creditos(self.username,self.password)    

    def stop_search_browser(self):
        self.sum_thread2.terminate()

        # Detener procesos de Chrome
        command = 'wmic process where "name=\'chrome.exe\' and commandline like \'%--remote-debugging-port%\'" get processid'
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        stdout, stderr = process.communicate()

        # Procesar la salida para obtener los IDs de proceso
        for pid in stdout.decode().split():
            if pid.isdigit():
                os.system(f'taskkill /PID {pid} /F > NUL 2>&1')

    def stop_search(self):
        self.sum_thread.terminate()
        self.movie = QMovie("./config/stop.gif")
        self.movie.setScaledSize(QSize(35, 35))  # Define el tamaño del GIF
        self.ui.status2.setMovie(self.movie)
        self.movie.start()
        self.ui.Stop.setEnabled(False)

        # Detener procesos de Chrome
        command = 'wmic process where "name=\'chrome.exe\' and commandline like \'%--remote-debugging-port%\'" get processid'
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        stdout, stderr = process.communicate()

        # Procesar la salida para obtener los IDs de proceso
        for pid in stdout.decode().split():
            if pid.isdigit():
                os.system(f'taskkill /PID {pid} /F > NUL 2>&1')

        # Detener procesos de Firefox
        command = 'wmic process where "name=\'firefox.exe\' and commandline like \'%--remote-debugging-port%\'" get processid'
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        stdout, stderr = process.communicate()

        # Procesar la salida para obtener los IDs de proceso
        for pid in stdout.decode().split():
            if pid.isdigit():
                os.system(f'taskkill /PID {pid} /F > NUL 2>&1')

        self.ui.erroneo2.setText('PAUSADO')

    def update_live(self,text):

        try:

            text1 = text.split('|')
            self.tools.minuscredits(self.username,self.password,text1[2])

            #data = text1[7]+' '+text1[8]+' '+text1[9]+' '+text1[10]+' '+text1[11]
            #tarjeta = text1[3] + '|' + text1[4] + '|' + text1[5] + '|' + text1[6] + '|' + data
            fecha_actual = datetime.now()
            fecha_formateada = fecha_actual.strftime('%Y-%m-%d %H:%M:%S')

            if text1 != None:

                try:
                    estado = text1[13]
                    if 'LOWFUNDS' in estado:
                        estado = 'LOWFUNDS'
                        pais = 'COL'
                except:
                    estado = "LIVE"

                entry = {

                    "fk_user_id": self.userid,
                    "gate": text1[2],
                    "cc": text1[3],
                    "mes": text1[4],
                    "year": text1[5],
                    "ccv": text1[6],
                    "type": text1[7],
                    "bank": text1[8],
                    "data": text1[9],
                    "franquicia": text1[10],
                    "pais": text1[11].split('\n')[0],
                    "fecha": fecha_formateada, # Usa la fecha formateada
                    "estado": estado
                }

                print(entry)
                cr = requests.put(urlHerokuGlobal + '//send',json=entry)
                self.ui.lives.append(text)

                credits = self.tools.get_creditos(self.username, self.password)

                self.ui.CREDITOSS.setText(str(credits))

                self.tools.escribir_en_archivo(text)
                Lc = int(self.ui.Lcont.text())+1
                self.ui.Lcont.setText(str(Lc))
                sound_file = "./config/check.wav" 
                pygame.mixer.init()
                pygame.mixer.music.load(sound_file)
                pygame.mixer.music.play()

        except Exception as e:
            self.app.signal_error.emit(f"Error actualizando live: {str(e)}")


    def update_text(self, text):
        self.ui.erroneo2.setText(text)

    def update_dead(self,text):
        self.ui.deads.append(text)
        Lc = int(self.ui.Dcont.text())+1
        self.ui.Dcont.setText(str(Lc))

    def show_ccs(self):
        os.startfile(os.getcwd()+"\\config\\CCS.txt")

    def clean(self):
        self.ui.lives.clear()
        self.ui.deads.clear()
        self.ui.log.clear()
        self.ui.Dcont.setText("0")
        self.ui.Lcont.setText("0")

    def mover_menu(self):
        if True:
            width = self.ui.frame_control.width()
            normal = 0
            if width == 0:
                extender = 200
            else:
                extender = normal
            self.animacion = QPropertyAnimation(self.ui.frame_control, b'minimumWidth')
            self.animacion.setDuration(300)
            self.animacion.setStartValue(width)
            self.animacion.setEndValue(extender)
            self.animacion.setEasingCurve(QtCore.QEasingCurve.InOutQuart)
            self.animacion.start()

    def soporte(self):
        msg_box = QMessageBox()
        msg_box.setWindowTitle("Soporte")
        msg_box.setText("Estos links te llevarán a los encargados de soporte. ¿A cuál quieres ir?")
        msg_box.addButton("Dashiro", QMessageBox.NoRole)
        msg_box.addButton("Mushiro", QMessageBox.NoRole)
        msg_box.addButton("Katakuri", QMessageBox.NoRole)

        respuesta = msg_box.exec_()

        api_url = urlHerokuGlobal + "/support"
        response = requests.get(api_url)
        data = response.json()

        if respuesta == 0:
            webbrowser.open(data['supp1'])
        elif respuesta == 1:
            webbrowser.open(data['supp2'])
        elif respuesta == 2:
            webbrowser.open(data['supp3'])
        else:
            pass

    def handle_error(self, message):
        # Mostrar el error en un QMessageBox
        QMessageBox.critical(self, "Error", message)
        
    
    def handle_exception(exc_type, exc_value, exc_traceback):

        if not issubclass(exc_type, KeyboardInterrupt):

            # Registra el traceback en el log file
            logger.error("Unhandled exception", exc_info=(exc_type, exc_value, exc_traceback))


            error_msg = f"Error desde handle_exception: {exc_value}\n"
            error_msg += f"Traceback:\n{''.join(traceback.format_exception(exc_type, exc_value, exc_traceback))}"

            # Personaliza el mensaje de acuerdo al tipo de error
            if "heroku" in str(exc_value):
                error_msg = 'Error en conexión! Revisa tu conexión a internet'
            
            if "cannot access local variable 'driver'" in str(exc_value):
                error_msg = 'Error en carga de driver! Presiona Parar e intenta nuevamente.'
            
            # Mensaje final de error en la consola
            print(error_msg)  # Imprimir en la consola para depuración

            # Mostrar el error en un QMessageBox
            QMessageBox.critical(None, "Error", error_msg)  # Muestra un cuadro de mensaje con el error
        

            #QApplication.instance().signal_error.emit(error_msg)  # Emite el error a través de una señal global

    sys.excepthook = handle_exception

# Configura el logger
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    filename='app.log',
    filemode='w'
)

# Ejemplo de cómo usar el logger
logger = logging.getLogger(__name__)
